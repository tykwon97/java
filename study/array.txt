<java>

타입[] 변수;
변수 = {값0,값1,값2.......}; // 컴파일 에러
-> 변수 =new 타입[] {값0,값1,값2.......};
-> 배열 변수를 미리 선언한 후, 값 목록들이 나중에 결정되는 상황이라면 다음과 같이 new연산자를 사용해서 값 목록을 지정해주면 된다.

메소드의 매개값이 배열인 경우 = 반드시 new 연산자를 사용해야됨
int add(int[] scores) {...}
int result = add({95,96,93}); //컴파일 에러
int result = add(new int[] {95,96,93}); //성공

new연산자로 배열을 생성할 경우에는 이미 배열 변수가 선언된 후에도 가능
타입[]변수 = new 타입[길이];
ex) int[] intArray = new int[5];
int타입 배열인 경우 기본값은 0으로 초기화된다.
string타입 배열인 경우 기본값은 NULL으로 초기화된다.

배열길이 : 배열변수.length;

다차원 배열
int[][] scores = new int[2][3];
scores.length;
scores[0].length;
scores[1].length;

String은 클래스 타입이므로 String[] 배열은 각 항목에 문자열이 아니라, String 객체의 주소를 가지고 있다. 즉 String 객체를 참조하게 된다.
-> String[]배열 항목 간에 문자열을 비교하기 위해서느 == 연산자 대신 equals() 메소드를 사용
==는 객체의 번지 비교이기 때문에 문자열 비교에 사용할 수 없다.

배열 복사 -> System.arraycopy()
System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
	-src매개값은 원본 배열이다.
	-srcPos는 원본 배열에서 복사할 항목의 시작 인덱스
	-dest매개값은 새 배열이다.
	-destPos는 새 배열에서 붙여넣을 시작 인덱스이다.
	-length는 복사할 개수

ex) 원본배열 = arr1, 새 배열 arr2, arr1의 모든 항목을 arr2에 복사
	->System.arraycopy(arr1,0,arr2,0,arr.length);

참조 타입 배열의 경우, 배열 복사가 되면 복사되는 값이 객체의 번지이므로 새 배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일하다. 이것을 얕은 복사(shallow copy)라고 한다. 
반대로 깊은 복사(deep copy)는 참조하는 객체도 별도로 생성하는 것을 말한다. 

열거 타입
	-데이터 중에는 몇 가지로 한정된 값만을 갖는 경우가 흔히 있다. 예를 들어 요일에 대한 데이터는 월, 화, 수, 목, 금, 토, 일이라는 일곱 개의 값만을 갖고,
	계절에 대한 데이터는 봄, 여름, 가을, 겨울이라는 네 개의 값만을 가진다. 이와 같이 한정된 값만을 갖는 데이터 타입이 열거 타입이다.
	열거 타입은 몇 개의 열거 상수 중에서 하나의 상수를 저장하는 데이터 타입이다.
-> 참조 타입 변수는 객체를 참조하는 변수라고 알고 있는데, 그렇다면 열거 상수는 객체일까?
    그렇다. 열거 상수는 열거 객체로 생성된다.



