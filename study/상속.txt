상속

상속을 해도 부모 클래스의 모든 필드와 메소드들을 물려받는 것은 아니다. 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다.그리고 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다.

자바는 다중 상속을 허용하지않는다.
-> extends 뒤에는 단 하나의 부모 클래스만 와야 한다.


부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.

부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다. 
super()는 부모의 기본 생성자를 호출한다.

메소드가 오버라이딩되었다면 부모 객체의 메소드는 숨겨지기 때문에, 자식 객체에서 메소드를 호출하면 오버라이딩된 자식 메소드가 호출된다.

메소드를 오버라이딩할 때는 다음과 같은 규칙에 주의해서 작성해야 한다.
- 부모의 메소드와 동일한 시그니처(리턴 타입, 메소드 이름, 매개 변수 리스트)를 가져야 한다.
- 접근 제한을 더 강하게 오버라이딩할 수 없다.
- 새로운 예외(Exception)를 throws할 수 없다.

자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 명시적으로 super 키워드를 붙여서 부모 메소드를 호출할 수 있다. super는 부모 객체를 참조하고 있기 때문에 부모 메소드에 직접 접근할 수 있다.

클래스를 선언할 때 final 키워드를 class 앞에 붙이게 되면 이 클래스는 최종적인 클래스이므로 상속할 수 없는 클래스가 된다. 즉 final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다는 것이다.
-> public final class String {...}
-> final 클래스의 대표적인 예는 자바 표준 API에서 제공하는 String 클래스이다.

메소드를 선언할 떄 final 키워드를 붙이게 되면 이 메소드는 최종적인 메소드이므로 오버라이딩 할 수 없는 메소드가 된다. 즉 부모 클래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의할 수 없다는 것이다.

protected는 public과 default 접근 제한의 중간쯤에 해당한다. 같은 패키지에서는 default와 같이 접근 제한이 없지만 다른 패키지에서는 자식 클래스만 접근을 허용한다.

왜 자동 타이 변환이 필요할까? 그냥 자식 타입으로 사용하면 될 것을 부모 타입으로 변환해서 사용하는 이유가 무엇일까? 그것은 다형성을 구현하는 기술적 방법 때문이다. 다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질을 말한다. 주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현하는데, 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로 저장하는냐에 따라 실행 결과가 달라질 수 있다. 이것이 필드의 다형성이다.

어떤 객체가 어떤 클래스의 인스턴스인지 확인하려면 instanceof 연산자를 사용할 수 있다. instanceof 연산자의 좌향은 객체가 오고, 우향은 타입이 오는데, 좌향의 객체가 우향의 인스턴스이면 즉 우향의 타입으로 객ㅊ가 생성되었다면 true를 산출하고 그렇지 않으면 false를 산출한다.
ex) boolean result = 좌향(객체) instanceof 우향(타입)

추상클래스는 새로운 실체 클래스를 만들기 위해 부모 클래스로만 사용된다. 코드로 설명하자면 추상클래스는 extends 뒤에만 올 수 있는 클래스이다. 예를 들어 Ant 클래스를 만들기 위한 Animal 클래스는 다음과 같다.
-> Class Ant extends Animal{...}
추상 클래스를 선언할 때에는 클래스 선언에 abstract 키워드를 붙여야한다. abstract를 붙이게되면 new 연산자를 이용해서 객체를 만들지 못하고 상속을 통해 자식 클래스만 만들 수 있다.
->
public abstract class 클래스 {
	//필드
	//생성자
	//메소드
}
추상 클래스도 일반 클래스와 마찬가지로 필드, 생성자, 메소드 선언을 할 수 있다. new 연산자로 직접 생성자를 호출할 수는 없지만 자식 객체가 생성될 때 super(...)를 호출해서 추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 반드시 있어야한다.